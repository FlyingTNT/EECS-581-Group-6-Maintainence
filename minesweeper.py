'''
File: minesweeper.py
Description: Implementation of a terminal based Minesweeper game made with Python.
Inputs: User gives input for uncovering or flagging cells and can change difficulty level by selecting bomb amount.
Outputs: Game board and progression is showed on display.
External sources: None
Authors: Bisshoy Bhattacharjee, Josh Welicky, Max Biundo, Marcus Kitchin, Gavin Billinger
Last updated: 9/19/2025
'''
import random
import os
import time

GRID_SIZE =  10

'''
Helper function to clear the terminal so output doesn't get too cluttered.
The clear command is different on windows vs linx/mac, so different 
os.system calls are needed.

This basic function structure was generated by the google search AI.
'''
def clear():
        # case for Windows OS
        if os.name == 'nt':
                os.system('cls')
        # case for Linux/MAC
        else:
                os.system('clear')
'''
A data structure that represents a single cell in a game grid. 
It contains all relevant information about the state of the cell, such as the number of adjacent mines, whether or not it has been uncovered, 
whether or not it contains a bomb, and whether or not it is currently flagged.
'''
class Cell:
        #Represents a single cell on the minesweeper board
        def __init__(self): # Initialize a cell with default values
                self.adjMines = 0 # Number of adjacent mines
                self.covered = True # If the cell is still covered
                self.bomb = False # If the cell contains a bomb
                self.flagged = False # If the cell is flagged by the player

        def __str__(self):
                #for debugging - shows bomb if uncovered
                if self.bomb and not self.covered:
                        return "ðŸ’£"
                if self.flagged:
                        return "ðŸš©" # Shows flag if flagged
                elif self.covered:
                        return '  ' # Empty string for covered cell
                else:
                        return f" {str(self.adjMines)}" # Show number of adjacent mines if uncovered
'''
Represents the actual grid in a game of Minesweeper. This class can be considered as a list with additional methods. 
In this program, the grid is represented as a single-dimensional list, where neighboring cells are derived mathematically through the getNeighbors method.
'''
class Board: # Represents the minesweeper board and handles neighbor calcualtions and display"
        # Initialize the board with 101 cell instances (inded 1-101) -(Changed to 1 to chosen grid size)

        def __init__(self): 
                self._board: list[Cell] = []
                for i in range(1, (GRID_SIZE * GRID_SIZE) + 2):
                        self._board.append(Cell()) # Create a new cell for each board position

        # OVERLOAD INDEXING
        def __getitem__(self, i):  
                if isinstance(i, int):
                        return self._board[i] # Return the cell at index i
                else:
                        raise # Raises error if index is not an integer
        
        # Returns the total number of cells on the board
        def __len__(self): 
                return len(self._board)
        

        # FUNCTION TO DISPLAY USER'S BOARD
        def display(self): 
                if GRID_SIZE == 10:
                        print('     A   B   C   D   E   F   G   H   I   J  ') # Prints column header

                elif GRID_SIZE == 15:
                        print('     A   B   C   D   E   F   G   H   I   J   K   L   M   N   O  ') 

                elif GRID_SIZE == 25:
                        print('     A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y  ') 
                test_string = ''
                for i in range(GRID_SIZE): # Loop over rows
                        for j in range(GRID_SIZE): # Loop over columns
                                index = (i * GRID_SIZE) + j + 1
                                test_string += '[' + str(self._board[index]) + ']'

                        row_num = str(i + 1)
                        padding = ' ' * (4 - len(row_num))
                        print(padding + row_num + test_string)
                        test_string = '' # Empty test string.
                return

        # Helps narrow the spaces to check bombs for a given space
        @staticmethod
        def getNeighbors(num): 
                # First, we'll classify the num as LeftEdge or RightEdge
                isLeftEdge = False
                isRightEdge = False
                if ((num-1)% GRID_SIZE) == 0: # This singles out 1, 11, 21, 31, etc as left edges.
                        isLeftEdge = True
                if (num% GRID_SIZE) == 0: # This singles out 10, 20, 30, 40, as right edges.
                        isRightEdge = True
                neighbors = []
                if not isRightEdge:
                        neighbors.append(num + 1) # Add right
                if not isLeftEdge:
                        neighbors.append(num - 1) # Add left
                if (num + GRID_SIZE < (GRID_SIZE * GRID_SIZE) + 1):
                        neighbors.append(num + GRID_SIZE) # Add down
                if (num - GRID_SIZE > 0):
                        neighbors.append(num - GRID_SIZE) # Add up
                if (not isLeftEdge) and (num - GRID_SIZE > 0):
                        neighbors.append(num - (GRID_SIZE + 1)) # Add up-left
                if (not isRightEdge) and (num - GRID_SIZE > 0):
                        neighbors.append(num - (GRID_SIZE - 1)) # Add up-right
                if (not isLeftEdge) and (num + GRID_SIZE < (GRID_SIZE * GRID_SIZE) + 1):
                        neighbors.append(num + GRID_SIZE - 1) # Add down-left
                if (not isRightEdge) and (num + GRID_SIZE < (GRID_SIZE * GRID_SIZE) + 1):
                        neighbors.append(num + GRID_SIZE + 1) # Add down-right
                return neighbors
        
        @staticmethod
        def getCellString(index: int) -> str:
                letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                letterIndex = ((index - 1) % GRID_SIZE)
                return letters[letterIndex] + str(((index // GRID_SIZE) + 1 - ( 1 if letterIndex == GRID_SIZE - 1 else 0)))

class AI:
        def __init__(self, difficulty: str):
                self.difficulty = difficulty

        def get_move(self, board: Board) -> int:
                if self.difficulty == "E":
                        return AI.easy(board)
                elif self.difficulty == "M":
                        return AI.medium(board)
                else:
                        return AI.hard(board)

        @staticmethod
        def easy(board: Board) -> int:
                """Return a random covered, unflagged cell as an index (-1 if none)"""
                candidates = [i for i in range(1, len(board)) if board[i].covered and not board[i].flagged]
                return random.choice(candidates) if candidates else -1

        @staticmethod
        def medium(board: Board) -> int:
                # row,col =random.randint(1, 11),random.randint(1, 11)
                # space = ((row - 1) * 10) + col
                # First, if the number of hidden neighbors of a revealed cell equals that cellâ€™s number, the AI should flag all hidden neighbors.
                rule_1_flag = 0
                rule_2_flag = 0
                bomb_count=0
                flag_count=0

                for i in range(len(board)):
                        if board[i].flagged==True:
                                flag_count+=1
                        if board[i].bomb==True:
                                bomb_count+=1

                for i in range(len(board)):  # check every cell
                        hidden_neighbors = 0
                        flagged_neighbors = 0
                        if board[i].covered == False:  # revealed is true
                                possible_neighbors = board.getNeighbors(i)
                                for neighbor in possible_neighbors:
                                        if board[neighbor].covered: #add to hidden neighbors if is covered
                                                hidden_neighbors += 1
                                if hidden_neighbors == board[i].adjMines:  # First, if the number of hidden neighbors of a revealed cell equals that cellâ€™s number, the AI should flag all hidden neighbors.
                                        for neighbor in possible_neighbors:
                                                if (flag_count + 1 <= bomb_count) and board[neighbor].covered == True:
                                                        board[neighbor].flagged = True
                                                        flag_count += 1

                                for neighbor in possible_neighbors: # get the amount of flag neighbors for rule 2
                                        if board[neighbor].flagged == True:
                                                flagged_neighbors += 1

                                if flagged_neighbors == board[i].adjMines:  # Second, if the number of flagged neighbors of a revealed cell equals that cellâ€™s number, the AI should open all other hidden neighbors.
                                        for neighbor in possible_neighbors:
                                                if board[neighbor].flagged == False:
                                                              return i


                return AI.easy(board)

        @staticmethod
        def hard(board: Board) -> int:
                """Get the index of the cell the hard AI would reveal

                Args:
                    board (Board): The current board state

                Returns:
                    int: The index in the board array of the cell to reveal.
                """
                # Pre-generate the neighbor indexes for each cell in the board
                AI.neighborsList = [Board.getNeighbors(i) for i in range(len(board))]

                # Set a timeout in three seconds.
                AI.timeout = time.time() + 3

                # Try to get a guaranteed safe cell. Will return -1 if it can't find one or if the timeout is reached
                safeCell = AI.getSafeCell(board)

                # If it found a safe cell, return that. Otherwise fall back to the medium AI
                return safeCell if safeCell > 0 else AI.medium(board)

        # A list of the neighbor indexes for each cell in the board, so that they aren't calculated over and over
        neighborsList = []

        # The timeout time for the hard AI
        timeout = 0

        @staticmethod
        def getSafeCell(board: Board) -> int:
                """Tries to get a cell on the given board that is guaranteed to be safe

                Will end early if the time is after AI.timeout

                Args:
                    board (Board): The board state

                Returns:
                    int: The index of the safe cell, or -1 if no such cell was founf
                """

                # A list where an index is -1 if its cell is covered, else it is the number of allowed adjacent mines
                allowedNeighbors = [(-1 if cell.covered else cell.adjMines) for cell in board]

                # A list of cells that can be ignored in the processing (because they have no useful information)
                ignoreCells = [True for _ in board]

                # When the function finds that a cell is unsafe, it will mark the corresponding index in this list
                # This reduces duplicated work because to show that a cell is unsafe, we find a valid board state where
                # that cell is a mine, and so we can also mark all other mined cells in that state as unsafe and not process
                # them again
                globalPlacedMines = [False for _ in allowedNeighbors]

                # The following loop finds all cells that are guaranteed to be mines because a number's number of unrevealed neighbor cells is equal to its number
                # It also updates the ignoreCells list to mark all useful cells as not ignored
                placedMine = True

                # While we found a new mine in the last iteration,
                while placedMine:
                        placedMine = False

                        # For each cell in the board
                        for i in range(1, len(allowedNeighbors)):
                                # If the cell is unrevealed, skip it
                                if allowedNeighbors[i] < 0:
                                        continue
                                
                                # Mark the cell as useful
                                ignoreCells[i] = False

                                # Get the neighbors of the cell
                                neighbors = AI.neighborsList[i]

                                # Mark all non-mine unrevealed neighbors as useful
                                for neighbor in neighbors:
                                        if ignoreCells[neighbor] and allowedNeighbors[neighbor] <= -1 and not globalPlacedMines[neighbor]:
                                                ignoreCells[neighbor] = False

                                # If this cell's number is zero, mark it as unuseful
                                if allowedNeighbors[i] == 0:
                                        ignoreCells[i] = True
                                        continue
                                
                                # Get all of the unrevealed non-mine neighbors
                                freeNeighbors = [cell for cell in neighbors if (allowedNeighbors[cell] <= -1 and not globalPlacedMines[cell])]

                                # If this cell's number is equal to the number of free neighbors
                                if allowedNeighbors[i] == len(freeNeighbors):
                                        # For each free neighbor
                                        for cell in freeNeighbors:
                                                # Mark it not useful
                                                ignoreCells[cell] = True

                                                # Mark it unsafe
                                                globalPlacedMines[cell] = True

                                                # For each of *its* neighbors, if it is a number cell, recalculate its number given this cell is a mine
                                                for index in AI.neighborsList[cell]:
                                                        if allowedNeighbors[index] < 0:
                                                                continue

                                                        allowedNeighbors[index] = board[index].adjMines
                                                        for nn in AI.neighborsList[index]:
                                                                if globalPlacedMines[nn]:
                                                                        allowedNeighbors[index] -= 1

                                        # Mark that we placed a mine this iteration
                                        placedMine = True

                # If there is any non-mine unrevealed cell that has a neighbor with number zero, return that cell
                for i in range(1, len(allowedNeighbors)):
                        if ignoreCells[i]:
                                continue

                        if allowedNeighbors[i] >= 0:
                                continue

                        if globalPlacedMines[i]:
                                continue

                        neighbors = AI.neighborsList[i]

                        for neighbor in neighbors:
                                if allowedNeighbors[neighbor] == 0:
                                        return i

                # 1-2-1 rule: if there are any cells in line in a 1-2-1 arrangement, the cells up/down from the 2 (or left/right if it is vertical) are guaranteed safe
                for i in range(1, len(allowedNeighbors)):

                        # If this cell is not a 2, skip it
                        if allowedNeighbors[i] != 2:
                                continue

                        # Get the indexes of the cells directly up, down, left, and right
                        up = i - GRID_SIZE
                        down = i + GRID_SIZE
                        left = i - 1
                        right = i + 1

                        # Check that the up/down/left/right indexes are good (this cell isn't on the corresponding edge of the board)
                        upGood = up > 0
                        downGood = down < len(allowedNeighbors)
                        leftGood = i % GRID_SIZE != 0
                        rightGood = i % GRID_SIZE != GRID_SIZE - 1

                        # If this is a vertical 1-2-1
                        if upGood and downGood and allowedNeighbors[up] == 1 and allowedNeighbors[down] == 1:
                                # If the left cell is valid and unrevealed, return it
                                if leftGood:
                                        if allowedNeighbors[left] < 0 and allowedNeighbors[down - 1] < 0 and allowedNeighbors[up - 1] < 0:
                                                return left
                                
                                # If the right cell is valid and unrevealed, return it
                                if rightGood:
                                        if allowedNeighbors[right] < 0 and allowedNeighbors[down + 1] < 0 and allowedNeighbors[up + 1] < 0:
                                                return right

                        # If this is a horizontal 1-2-1
                        if leftGood and rightGood and allowedNeighbors[left] == 1 and allowedNeighbors[right] == 1:
                                # If the up cell is valid and unrevealed, return it
                                if upGood:
                                        if allowedNeighbors[up] < 0 and allowedNeighbors[up - 1] < 0 and allowedNeighbors[up + 1] < 0:
                                                return up

                                # If the down cell is valid and unrevealed, return it
                                if downGood:
                                        if allowedNeighbors[down] < 0 and allowedNeighbors[down - 1] < 0 and allowedNeighbors[down + 1] < 0:
                                                return down
                
                # If none of the above rules apply, use a recursive algorithm to try and find a safe cell
                # This will never return a unsafe cell, but may fail to find a safe cell if the timeout is hit
                for i in range(1, len(allowedNeighbors)):
                        # If the timeout is hit, stop checking
                        if time.time() > AI.timeout:
                                break

                        # If this cell is marked ignored, skip it
                        if ignoreCells[i]:
                                continue

                        # If this cell is revealed, skip it
                        if allowedNeighbors[i] >= 0:
                                continue
                        
                        # If this cell is already known to be unsafe, skip it
                        if globalPlacedMines[i]:
                                continue

                        # Get the 'loop' of all useful cells connected to this one. The algorithm will solve the entire loop at once.
                        loop: list[int] = []
                        AI.getLoop(ignoreCells, i, loop)

                        # Solve the loop. This will mark all cells found to be unsafe in globalPlacedMines
                        # It will return the index of a guaranteed safe cell, if one exists in the loop (unless the timeout was hit)
                        solution = AI.solveLoop(allowedNeighbors, loop, globalPlacedMines)

                        # If a guaranteed safe cell was found, return it
                        if solution != -1:
                                return solution
                        
                        # Mark all cells in the loop as ignored (because they have already been solved)
                        for cell in loop:
                                ignoreCells[cell] = True

                # If we found no safe cell, return -1
                return -1
        
        @staticmethod
        def canPutMine(allowedNeighbors: list[int], cell: int) -> bool:
                """Checks whetehr the given cell would be a valid spot for a mine based on the given allowedNeighbors array

                Args:
                    allowedNeighbors (list[int]): An array of the number of neighboring bombs each cell is allowed to have
                    cell (int): The cell to check

                Returns:
                    bool: True if no neighbors have 0 allowed neighboring bombs or False otherwise
                """
                # If this cell is revealed, return false
                if allowedNeighbors[cell] >= 0:
                        return False

                # If any neighbor has 0 allowed neighboring bombs, return false
                for index in AI.neighborsList[cell]:
                        if allowedNeighbors[index] == 0:
                                return False
                
                return True

        @staticmethod
        def putMine(allowedNeighbors: list[int], cell: int) -> bool:
                """Updates allowedNeighbors to reflect a mine being placed on the given cell, if such a mine would be valid

                Args:
                    allowedNeighbors (list[int]): An array of the number of neighboring bombs each cell is allowed to have
                    cell (int): The cell to mine

                Returns:
                    bool: True if the given cell was allowed to have a mine or False otherwise
                """
                # If the cell is revealed, return False
                if allowedNeighbors[cell] >= 0:
                        return False

                # Get the cell's neighbors
                neighbors = AI.neighborsList[cell]

                # If any neighboring cell can't have any neighboring mines, return false
                for index in neighbors:
                        if allowedNeighbors[index] == 0:
                                return False
                
                # Place the mine (decrement the number of allowed adjacent mines of all neighbors)
                for index in neighbors:
                        allowedNeighbors[index] -= 1
                
                return True

        @staticmethod 
        def removeMine(allowedNeighbors: list[int], cell: int):
                """Undoes the changes made in a putMine() action

                Args:
                    allowedNeighbors (list[int]): An array of the number of neighboring bombs each cell is allowed to have
                    cell (int): The cell to remove a mine from
                """

                # Remove the mine (increment the number of allowed adjacent mines of all neighbors)
                for index in AI.neighborsList[cell]:
                        allowedNeighbors[index] += 1

        @staticmethod
        def getLoop(ignore: list[bool], cell: int, loop: list[int]):
                """Gets all non-ignored cells connected to the given cell and adds them to the given list

                Args:
                    cell (int): The cell to get the loop of
                    loop (list[int]): The list to add items to
                """
                # If this cell is ignored, skip it
                if ignore[cell]:
                        return
                
                # Add the cell to the loop
                loop.append(cell)

                # Mark to ignore the cell (so we don't recurse down it again)
                ignore[cell] = True

                # Recurse to every neighbor of the cell
                for index in AI.neighborsList[cell]:
                        AI.getLoop(ignore, index, loop)
        
        @staticmethod
        def solveLoop(allowedNeighbors: list[int], loop: list[int], globalPlacedMines: list[bool]) -> int:
                """Solves the given loop of cells by either returning the index of a safe cell or marking all of the cells in the loop as unsafe in globalPlacedMines

                May end early if AI.timeout is hit

                Args:
                    allowedNeighbors (list[int]): An array of the number of neighboring bombs each cell is allowed to have
                    loop (list[int]): The cells in the loop to solve
                    globalPlacedMines (list[bool]): A list of whether each cell is known to be unsafe

                Returns:
                    int: -1 if no guaranteed safe cell was found, or the index of the cafe cell otherwise
                """

                # For each cell in the loop
                for i in loop:
                        # If we've hit the timeout, return -1
                        if time.time() > AI.timeout:
                                return -1

                        # If the cell is already known to be unsafe, skip it
                        if globalPlacedMines[i]:
                                continue

                        # If the cell is revealed, skip it 
                        if allowedNeighbors[i] >= 0:
                                continue

                        # Try to put a mine on the cell; if we can't return the cell
                        if not AI.putMine(allowedNeighbors, i):
                                return i
                        
                        # A list of cells that can't be mines in this board state
                        banned = [not AI.canPutMine(allowedNeighbors, i) for i in range(len(allowedNeighbors))]
                        
                        # A list where an index is True if its cell is a mine in the current solution as we're building it recursively
                        thisPlacedMines = [False for _ in allowedNeighbors]
                        thisPlacedMines[i] = True

                        # Try to find a soltion given that this cell is a mine. If we can, this cell is unsafe.
                        if AI.tryFindSolution(allowedNeighbors, loop, thisPlacedMines, globalPlacedMines, banned, 0):
                                AI.removeMine(allowedNeighbors, i)
                                continue
                        
                        # If we didn't find a solution, this cell is safe, so return it
                        AI.removeMine(allowedNeighbors, i)
                        return i
                
                # If we found no safe cell, return -1
                return -1


        @staticmethod
        def tryFindSolution(allowedNeighbors: list[int], loop: list[int], thisPlacedMines: list[bool], globalPlacedMines: list[bool], banned: list[bool], start: int) -> bool:
                """Tries to find a valid solution for the given loop in the given board state

                May end early if AI.timeout is reached

                Args:
                    allowedNeighbors (list[int]): An array of the number of neighboring bombs each cell is allowed to have
                    loop (list[int]): The cells that need to be considered in the solution (all other cells are independent)
                    thisPlacedMines (list[bool]): An array where an elemnt is True if it is a bomb in this board state
                    globalPlacedMines (list[bool]): A list of whether each cell is known to be unsafe
                    banned (list[bool]): A list of cells that cannot be bombs in this board state
                    start (int): The index in the loop to start checking from

                Returns:
                    bool: True if there is a soltution for the given borad state or the timeout was reached, or False otherwise
                """

                # Check if the board is already solved
                solved = True
                
                # If any of the items have at least 1 allowed neighboring bomb, it is not solved
                for item in loop:
                        if allowedNeighbors[item] > 0:
                                solved = False
                                break
                
                # If it is solved, mark all of the mines in the solution as unsafe in globalPlacedMines and return True
                if solved:
                        for i, canBeMine in enumerate(thisPlacedMines):
                                if canBeMine:
                                        globalPlacedMines[i] = True
                        return True

                # For each cell in the loop,
                for i, cell in enumerate(loop):
                        # If we've hit the timeout, return True
                        if time.time() > AI.timeout:
                                return True
                        
                        # If this cell is before the start (has already been checked), skip it
                        if i < start:
                                continue

                        # If this cell is already a mine in this solution, skip it
                        if thisPlacedMines[cell]:
                                continue

                        # If this cell is known to not be a mine in this solution, skip it
                        if banned[cell]:
                                continue
                        
                        # Try to make this cell a mine. If it can't be one, skip it
                        if not AI.putMine(allowedNeighbors, cell):
                                continue

                        # Mark that this cell is a mine in the current solution
                        thisPlacedMines[cell] = True

                        # For each neighbor of the cell, update its banned value
                        for neighbor in AI.neighborsList[cell]:
                                if not AI.canPutMine(allowedNeighbors, neighbor):
                                        banned[neighbor] = True

                        # Try to find a solution given this cell is a mine. If we did, return true.
                        if AI.tryFindSolution(allowedNeighbors, loop, thisPlacedMines, globalPlacedMines, banned, i + 1):
                                AI.removeMine(allowedNeighbors, cell)
                                return True
                        
                        # If we didn't find a solution where this cell is a mine, unmark it as a mine in this solution
                        AI.removeMine(allowedNeighbors, cell)
                        thisPlacedMines[cell] = False

                        # For each neighbor of the cell, update its banned value
                        for neighbor in AI.neighborsList[cell]:
                                if AI.canPutMine(allowedNeighbors, neighbor):
                                        banned[neighbor] = False
                
                # Check if the board is already solved
                solved = True
                
                # If any of the items have at least 1 allowed neighboring bomb, it is not solved
                for item in loop:
                        if allowedNeighbors[item] > 0:
                                solved = False
                                break
                
                # If it is solved, mark all of the mines in the solution as unsafe in globalPlacedMines and return True
                if solved:
                        for i, canBeMine in enumerate(thisPlacedMines):
                                if canBeMine:
                                        globalPlacedMines[i] = True
                        return True
                
                # Return that we didn't find a solution
                return False




'''
An entity that represents a single game of Minesweeper and all of its relevant information, including game status, bomb counts, flagged cell counts, start time, and the game grid. 
It also contains the functionality for obtaining user commands and handling all game logic.
'''        
class Game:
        # Handles game logic like moves, win/loss checking, and propagation
        def __init__(self): # Initialize the game state and create a board
                self.status = 'Playing' # Current game state
                self.flag_ct = 0 # Number of flags currently placed
                self.bomb_ct = 0 # Total bombs in the game
                self.bomb_spaces = [] # List of bomb positions
                self.start_time = time.time() #initialize the start time of the game
                #self.board = Board() # initialize the game board
                self.score = 0 # initialize score
                self.total_moves = 0 # initialize total moves
                self.wrong_flags = 0 # initialize wrong flags)
                self.mode = 'solo' # modes: solo, vsAI, soloAI
                self.turn = 'human' # Keep track of turn for vsAI mode
                self.ai = None # For AI instance if in vsAI or soloAI mode
        
        def caclulateScore(self):
                # Count only real board indices (1..N); index 0 is unused in this implementation
                safe_cells = sum(1 for i in range(1, len(self.board)) if not self.board[i].bomb)
                # Safe cells that have been uncovered
                revealed_safe = sum(1 for i in range(1, len(self.board)) if (not self.board[i].bomb) and (not self.board[i].covered))
                # Flags that correctly mark bombs are considered "revealed" for scoring
                correct_flags = sum(1 for i in range(1, len(self.board)) if self.board[i].bomb and self.board[i].flagged)

                # Avoid division by zero so if no safe cells, consider board fully cleared
                if safe_cells == 0:
                        percent_cleared = 1.0
                else:
                        percent_cleared = (revealed_safe + correct_flags) / safe_cells
                        # Clamp to [0,1] just in case
                        percent_cleared = max(0.0, min(1.0, percent_cleared))

                base_score = (self.bomb_ct * 10) - (self.wrong_flags * 5)
                computed = base_score * percent_cleared
                if computed < 0:
                        computed = 0
                # Round for display / storage
                self.score = round(computed, 2)
                return self.score

        # Helper function to check the elapsed time of the game
        def timeCheck(self):
                cur_time = time.time() #check the time
                elapsed_time = cur_time - self.start_time #subtract the start time from recent check
                return elapsed_time #return the current time unformatted
        

        #function to display the current time to the user
        def displayTime(self): 
                elapsed_time = self.timeCheck() #do a time check
                hours = int(elapsed_time // 3600 % 24) #mathematical functions to formate raw number
                minutes = int(elapsed_time // 60 % 60)
                seconds = int(elapsed_time % 60)
                formatted_time = f"{hours:02d}:{minutes:02d}:{seconds:02d}" #format into hh:mm:ss
                print("Time:", formatted_time) #print


        # Display the current board, game status, and number of remaining mines
        def printGame(self): 
                self.displayTime()
                self.board.display() # Print the board
                print("Current status:", self.status) # Shows game status
                print("Mines remaining:", self.bomb_ct - self.flag_ct, "\n") # Shows remaining mines
                if self.status != "Playing":
                        print("Final Score:", round(self.caclulateScore(), 2)) # Show final score if game is over
                return


        # Places bombs within the Cell instances stored in board. Requires bomb_spaces to be derived first.
        def placeBombs(self): 
                for i in range(len(self.bomb_spaces)):
                        bomb_idx = self.bomb_spaces[i] # Get location of bomb
                        self.board[bomb_idx].bomb = True # Insert bomb character

                # Now we just need to fill values around bombs!

                for i in range(1, len(self.board)): # For every space in the board we need to find how many bombs are around it.
                        if (self.board[i].bomb):
                                continue # We don't need the value where bombs are so we skip.
                        space_val = 0
                        neighbors = Board.getNeighbors(i) # We'll get the valid indices in separate function.
                        for index in neighbors: # Iterate through neighbor list
                                if (self.board[index].bomb): # If the board at that neighbor is a bomb...
                                        space_val += 1 # ...increment space value
                        self.board[i].adjMines = space_val # Set value at that board space.


        # Recursively uncovers neighbouring cells starting from a cell with 0 nearby mines.
        def propagate(self, space): 
                self.board[space].covered = False
                neighbors = Board.getNeighbors(space)
                for neighbor in neighbors: # if neighbour has 0 adjacent mines and is not flagged, it will recusively uncover
                        if self.board[neighbor].adjMines == 0 and self.board[neighbor].flagged == False:
                                if self.board[neighbor].covered:
                                        self.propagate(neighbor)
                        elif self.board[neighbor].flagged: # Skip flagged cells
                                continue
                        else:
                                #print(f"Cell {neighbor}")
                                self.board[neighbor].covered = False


        # Display an error message and wait for the user to press "ENTER". Needed to preserve help messages before clearing terminal.
        def printErr(self, msg): 
                print(msg)
                input("Press [ENTER] to continue...\n")


        # Obtains an input from the user and parses it into a game command, broken into [action, row, column].
        def getInput(self):
                i = True
                while i:
                        try:
                                inp_string = input('Mine a cell with m[row][col].\nToggle a flag with f[row][col].\nPlease give command: ') # Ask for command.
                                com_type = inp_string[0].lower() # Parse first character for command type ("m" or "f")
                                if com_type != 'm' and com_type != 'f':
                                        raise
                                inp_string = inp_string[1:len(inp_string)] # Remove first character from input string.
                
                                col = inp_string[len(inp_string)-1] # Look at end of input string for column letter.
                                cols = [chr(97 + i) for i in range(GRID_SIZE)]
                                if col not in cols:
                                        raise
                                col = cols.index(col) + 1 # Translate that column into numerical column position.
                                inp_string = inp_string[:len(inp_string)-1] # Remove last character from input string.
                
                                row = int(inp_string) # What's remaining of input string should be row number.
                                if row not in range(1, GRID_SIZE + 1):
                                        raise
                                i = False
                        except:
                                err_msg = '\nCommand is faulty please follow command, row, column format.\n(Hint 1: To mine at row 1, column a, type "m1a")\n(Hint 2: To flag at row 7, column g, type "f7g")'
                                self.printErr(err_msg)
                                continue
                
                command = [] # Create command value.
                command.append(com_type) # Add the "m" or "f"
                command.append(row) # Add row number.
                command.append(col) # Add column number.
                return command # Return parsed input.



        #Collects the bomb amount from the user and generates an initial list of bomb space indices.
        #Feature added: indludes a grid size option
        def configure(self):
                global GRID_SIZE
                # Collect grid size preference using same structure
                i = 0
                while i == 0:
        
                        size_input = input("Chose Grid Size - Small 10 x 10, Medium 15 x 15, Large 25 x 25 (Please enter s, m or l): ").lower()

                        if size_input == 's':
                                        GRID_SIZE = 10 
                                        i = 1
                        elif size_input == 'm':
                                        GRID_SIZE = 15
                                        i = 1
                        elif size_input == 'l':
                                        GRID_SIZE = 25
                                        i = 1 
                        else: 
                                print("Invalid Grid Size")
                self.board = Board() #update board size 
                                
                # COLLECT BOMB AMOUNT (DIFFICTULTY)
                # The added feature includes adding a different range for each grid size 

                #calculate minnimum an maximum for bomb sizes
                bomb_min =  (GRID_SIZE * GRID_SIZE)// 10
                bomb_max = (GRID_SIZE * GRID_SIZE) // 5
                i = 0 
                while i == 0: # This while loop is purely for error handling. We don't stop asking until we get workable input!
                        try:
                                self.bomb_ct = int(input('How many bombs should there be?: '))
                                if self.bomb_ct < bomb_min or self.bomb_ct > bomb_max: # Bomb count must be between 10 and 20 per the requirements. (Changed to 10-20% of grid size)
                                        raise
                                i = 1
                        except:
                                print("Invalid bomb count. Please input again.")

                self.bomb_spaces = random.sample(range(1,((GRID_SIZE * GRID_SIZE) + 1)), self.bomb_ct) # Randomly select bomb locations on the board without duplicates

                # Get mode
                while True:
                        mode = input("Select the game mode (solo / vsAI / soloAI): ").strip().lower()
                        if mode in ('solo', 'vsai', 'soloai'):
                            break
                        print("Please enter 'solo', 'vsAI', or 'soloAI'.")
                
                self.mode = mode
                
                # Get AI difficulty if needed
                if self.mode in ('vsai', 'soloai'):
                        while True:
                            diff = input("Select the AI difficulty (E/M/H): ").strip().upper()
                            if diff in ('E','M','H'):
                                break
                            print("Please enter E, M, or H.")
                        self.ai = AI(diff)


        '''
        Main game logic function. First, it obtains a valid command from the user and derives the space from the last two components. 
        Handles the operations necessary to flag a Cell(directly alters a Cell's flagged attribute) and handles all rule checks. 
        If the command is to mine, the Cell is uncovered. If the Cell has no adjacent mines, propagate() is called, which uncovers the Cell automatically. 
        If not, the Cell is uncovered directly in move(). Behavior is slightly different based on the prebomb attribute. 
        If it is set to True, the selected space is checked for presence in the randomly generated bomb_spaces list. 
        If it is present, then a new bomb_space is generated. 
        Once the bomb_spaces list is adjusted, placeBombs() is called, installing bombs in the board attribute. 
        Then, the Cell is uncovered as normal. If a bomb space is selected and prebomb is False, all bomb spaces are uncovered, and the game status is set to â€œGame Over: Lossâ€.
        '''
        def move(self, prebomb=False):
                self.total_moves += 1 # Increment total moves
                user_input = self.getInput() # Helper function gives us actionable command.
                space = ((user_input[1]-1) * GRID_SIZE) + user_input[2] # Translate col and row from input into board space.
                
                if user_input[0] == 'f': # If we got a flag command, we place the flag on display.
                        if not self.board[space].flagged: # Empty space means flag is allowed.
                                        if self.checkBombPlacement() and self.flag_ct + 1 > self.bomb_ct: # Also got to check that we don't place too many flags.
                                                self.printErr("Cannot flag any more spaces. Please unflag with flag command.")
                                        elif not self.board[space].covered:
                                                self.printErr("Cannot flag an uncovered space.")
                                        else:
                                                self.board[space].flagged = True # Put a flag on the display!
                                                self.flag_ct += 1 # Increment the amount of flags on board.
                                                if not self.board[space].bomb:
                                                        self.wrong_flags += 1 # Increment wrong flags if flag is placed on non-bomb space
                        elif self.board[space].flagged: # Flag exists in current space, remove it.
                                self.board[space].flagged = False # Set flag to empty space.
                                self.flag_ct -= 1 # Decrement the amount of flags on board.
                
                elif user_input[0] == 'm': # We have a mine command!
                        if self.board[space].flagged: # Are we mining on a flag space?
                                self.printErr('Cannot mine a flag given space.') # We don't actually do anything. We just say a flag is in the way.
                        else:
                                if prebomb:
                                        # SPACE-BOMB COLLISION PROBLEM
                                        if space in self.bomb_spaces: # In the event the selected space is where a mine was planned to be...
                                                problem_index = self.bomb_spaces.index(space) # Isolate where in the list of bomb spaces the user space and bomb collide.
                                                while space == self.bomb_spaces[problem_index]: # While these two values are the same...
                                                        self.bomb_spaces[problem_index] = random.randint(1, GRID_SIZE * GRID_SIZE) # ...we will reroll that bomb space.
                                                        i = 0 # Then we'll check how many times the new bomb space value appears.
                                                        for place in self.bomb_spaces: # Check every bomb space
                                                                if self.bomb_spaces[problem_index] == place: # If the new space appears in bomb spaces, increment.
                                                                        i += 1 # This should increment only once (when the new space compares itself).
                                                        if i > 1: # If the new bomb space increments multiple times, we still have a collision.
                                                                self.bomb_spaces[problem_index] = space # We can't let the while loop end so reset with space.
                                        
                                        # CALL BOARD GENERATION
                                        self.placeBombs()
                                        # UPDATE BOARD w/ FIRST SPACE
                                        if self.board[space].adjMines == 0:
                                                self.propagate(space) # Reveal spaces around the 0 space.
                                        else:
                                                self.board[space].covered = False
                                else:
                                        # There's a few things we check here:
                                                # Is the space a bomb?
                                                # Is the space a flag?
                                                # Is the space 0?
                                                # Is the space any other value?
                                        # We will check if the space is a bomb next.
                                        if self.board[space].bomb:
                                                for bomb in self.bomb_spaces: # Reveal all bombs on the board.
                                                        self.board[bomb].covered = False
                                                self.status = "Game Over: Loss" # Lose the game.
                                        # We will check if the space is the value 0.
                                        elif self.board[space].adjMines == 0: # 0 is a special value because we...
                                                self.propagate(space) # ...reveal the neighbor values.
                                        # The space must be empty and a regular number. Reveal it!
                                        else:
                                                self.board[space].covered = False

        def move_AI(self, space, prebomb=False):
            if prebomb:
                # SPACE-BOMB COLLISION PROBLEM
                if space in self.bomb_spaces: # In the event the selected space is where a mine was planned to be...
                        problem_index = self.bomb_spaces.index(space) # Isolate where in the list of bomb spaces the user space and bomb collide.
                        while space == self.bomb_spaces[problem_index]: # While these two values are the same...
                                self.bomb_spaces[problem_index] = random.randint(1, 100) # ...we will reroll that bomb space.
                                i = 0 # Then we'll check how many times the new bomb space value appears.
                                for place in self.bomb_spaces: # Check every bomb space
                                        if self.bomb_spaces[problem_index] == place: # If the new space appears in bomb spaces, increment.
                                                i += 1 # This should increment only once (when the new space compares itself).
                                if i > 1: # If the new bomb space increments multiple times, we still have a collision.
                                        self.bomb_spaces[problem_index] = space # We can't let the while loop end so reset with space.
                
                # CALL BOARD GENERATION
                self.placeBombs()
                # UPDATE BOARD w/ FIRST SPACE
                if self.board[space].adjMines == 0:
                        self.propagate(space) # Reveal spaces around the 0 space.
                else:
                        self.board[space].covered = False
            else:
                    # There's a few things we check here:
                            # Is the space a bomb?
                            # Is the space a flag?
                            # Is the space 0?
                            # Is the space any other value?
                    # We will check if the space is a bomb next.
                    if self.board[space].bomb:
                            for bomb in self.bomb_spaces: # Reveal all bombs on the board.
                                    self.board[bomb].covered = False
                            self.status = "Game Over: Loss" # Lose the game.
                    # We will check if the space is the value 0.
                    elif self.board[space].adjMines == 0: # 0 is a special value because we...
                            self.propagate(space) # ...reveal the neighbor values.
                    # The space must be empty and a regular number. Reveal it!
                    else:
                            self.board[space].covered = False

        #Checks if all non-bomb spaces are uncovered. Doesn't return anything, but sets status to Victory if necessary.
        def checkWin(self):
                # CHECK WIN CONDITION
                remaining_space_check = 0
                for index in range(1, len(self.board)): # Compare all board spaces
                        if self.board[index].covered:
                                remaining_space_check += 1 # Increment remaining empty or flagged spaces.
                if remaining_space_check == self.bomb_ct: # When there are the same amount of empty or flagged spaces as bombs on the field...
                        self.status = "Victory!" # The game has been won! End game loop.
                    

        # Check if all bombs have been correctly placed on the board. Needed to ensure first mined cell doesn't actually have a bomb in it.
        def checkBombPlacement(self): 
                bombed_spaces = 0
                for index in range(1, len(self.board)):
                        if self.board[index].bomb:
                                bombed_spaces += 1 # Count the number of bombs currently on the board
                return bombed_spaces == self.bomb_ct # Return true if bomb count matches the intended total


        '''
        Comprises the main game loop. Initially configures the game with configure(). 
        Then, runs a while loop, which prints the state of the game (printGame()) and requests a command (move()). 
        The optional parameter for move is set to True in this loop(see move() description). 
        This loop ends once the bombs have been placed (once the user uncovers their first cell). 
        After that, another loop begins, performing essentially the same function, with two differences. 
        The optional command in move() is no longer set, and the checkWin() function is called at the end of every iteration. 
        The loop breaks once the game status is no longer â€œPlayingâ€.
        '''
        def play(self): # Configures the board, processes moves, and handle win/loss
                self.configure() # Ask user for bomb count, mode, AI difficulty (if needed), and generate bomb locations
                
                if self.mode == 'solo':
                        while not self.checkBombPlacement(): # Makes sure bombs are properly placed before starting the game
                                self.printGame()
                                #print(f"Bomb Spaces: {self.bomb_spaces}")
                                self.move(True)
                                clear()
                        while self.status == 'Playing':
                                self.printGame() # Display the current board
                                #print(f"Bomb Spaces: {self.bomb_spaces}")
                                self.move()
                                self.checkWin()
                                clear() # Clear screen for a fresh board display
                        self.printGame()
                        return

                if self.mode == 'vsai':
                        # Human always does the first move
                        while not self.checkBombPlacement(): # Makes sure bombs are properly placed before starting the game
                                self.printGame()
                                self.move(True)
                                self.turn = 'ai'
                                clear()
                        while self.status == 'Playing':
                                # Human turn
                                self.printGame() # Display the current board
                                if self.turn == 'human':
                                        self.move()
                                        self.checkWin()
                                        self.turn = 'ai'
                                        clear() # Clear screen for a fresh board display
                                        continue
                                
                                # AI turn
                                ai_index = self.ai.get_move(self.board)
                                if ai_index > 0:
                                    self.move_AI(ai_index)
                                self.checkWin()
                                self.turn = 'human'
                                clear()
                        self.printGame()
                        return

                if self.mode == 'soloai':
                        # AI makes the first safe uncover
                        while not self.checkBombPlacement():
                            self.printGame()
                            ai_index = self.ai.get_move(self.board)
                            if ai_index > 0:
                                self.move_AI(ai_index, True)
                            clear()
                
                        # AI continues playing until victory or loss
                        while self.status == 'Playing':
                            self.printGame()
                            ai_index = self.ai.get_move(self.board)
                            if ai_index > 0:
                                self.move_AI(ai_index)
                            self.checkWin()
                            clear()

                self.printGame()
                return

'''
Entity that coordinates initial contact with the user. It is responsible for printing an initial introductory message, as well as enabling multiple games per execution.
'''
class GameManager: # Handles showing instructions, new games, and replayability
        #GameManager doesn't need any attributes.
        def __init__(self):
                return
        
        # Creates a new game instance and start playing it
        def newGame(self): 
                newgame = Game()
                newgame.play()
        
        # Display the initial instruction to the player.
        def start_message(self): 
                print('Welcome to Minesweeper!')
                print('--------------------------------')
                print('HOW TO PLAY:')
                print('- Goal: uncover all safe spaces without hitting a mine.')
                print('- The numbers show how many mines are in the surrounding spaces.')
                print('- Commands (one command per turn):')
                print('    m[row][col] â†’ Uncover a space.')
                print('        Example: m3b means uncover row 3, column b.')
                print('    f[row][col] â†’ Flag or unflag a space.')
                print('        Example: f5h means place/remove a flag at row 5, column h.')
                print('- Win by uncovering every safe space. If you hit a mine, you lose!.')
                print('--------------------------------')
       
        # Start the game manager to show introduction instrution, run game and handle replays.
        def start(self):
                self.start_message() # Displays instruction to player
                while True:
                        self.newGame() # Start a new game
                        choice = input("Play again?(yes/no): ") # Ask if player want to reply
                        if choice.lower() == 'yes' or choice.lower() == 'y':
                                clear() # Clear screen for a fresh game
                                continue # Starts new game
                        else:
                                break # Exit loop and end the program

# Create a GameManager instance and start the minesweeper game
def main(): 
        manager = GameManager()
        manager.start()

main()
